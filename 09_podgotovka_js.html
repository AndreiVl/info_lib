
<html lang="ru">
    <head>
      <meta charset="utf-8"/>
      <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
      <meta name="viewport" content="width=device-width, initial-scale=1"/>
      <link rel="icon" href="images/favicon.ico"/>
      <title></title>
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/vs2015.min.css"/>
      <link href="css/jquery.modal.min.css" rel="stylesheet"/>
      <link href="css/prism.css" rel="stylesheet"/>
      <link href="css/style.css" rel="stylesheet"/>
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script><!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->
    </head>
  <body>
    <div class="wrapper">
            <section class="page-info">
              <div class="page-info__sidebar">
                <div class="page-info__wrapper-menu">
                  <div class="page-info__menu">
                    <h2 class="page-info__title">Меню</h2>
                    <ol class="page-info__menu-list">
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-1">Основные принципы работы с DOM, Fetch и Storage</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-2">Занятие 2: Spread Операторы и Деструктуризация Объектов</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-3">Занятие 3: Циклы, Типы и Структуры Данных</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-4">Промисы, Async/Await, Замыкания, Области Видимости и Контекст</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-5">Занятие 5: Работа с Local Storage и Session Storage</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-6">Занятие 6: Map, Set и Связанные Списки</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-7">Занятие 7: Работа с Timeout, SetInterval и Очистка Интервалов</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-8">Занятие 8: Понимание Рекурсии и Избавление от Неё</a></li>
                      <li class="page-info__menu-item"><a class="page-info__menu-link link-anchor" href="#page-info-training-9">Занятие 9: Обработка Ошибок и Базовая Отладка с Debugger</a></li>
                    </ol>
                  </div>
                </div>
              </div>
              <div class="page-info__body">
                <h2 id="page-info-training-1">Занятие 1: Основные принципы работы с DOM, Fetch и Storage</h2>
                <ol>
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>DOM (Document Object Model): </b>Структура HTML-документа в виде дерева объектов. Работа с элементами через JavaScript.</p>
                        <ul>
                          <li> 
                            <p>Основные методы: <code class="page-info__code">getElementById, querySelector, createElement, appendChild, removeChild, innerHTML. </code></p>
                          </li>
                          <li> 
                            <p>События: <code class="page-info__code">click, mouseover, keydown</code> и их обработчики <code class="page-info__code">(addEventListener).</code></p>
                          </li>
                        </ul>
                      </li>
                      <li> 
                        <p> <b>Fetch API:</b>Современный способ взаимодействия с сервером для отправки HTTP-запросов.</p>
                        <ul>
                          <li> 
                            <p>Методы: <code class="page-info__code">GET, POST, PUT, DELETE.</code></p>
                          </li>
                          <li> 
                            <p>Промисы и обработка ответа: <code class="page-info__code">.then(response => response.json()).then(data => {...}).</code></p>
                          </li>
                        </ul>
                      </li>
                      <li> 
                        <p> <b>Storage API:</b>Способы хранения данных на стороне клиента.</p>
                        <ul> 
                          <li> 
                            <p> <code class="page-info__code">localStorage:</code> данные сохраняются на постоянной основе.   </p>
                          </li>
                          <li> 
                            <p> <code class="page-info__code">sessionStorage:</code>  данные сохраняются в течение одной сессии.</p>
                          </li>
                          <li> 
                            <p>Методы:<code class="page-info__code">setItem, getItem, removeItem, clear.</code></p>
                          </li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p> <b>Работа с DOM: </b></p>
                        <pre><code class="language-javascript">// Изменение текста элемента
document.getElementById('myElement').textContent = 'Новый текст';</code></pre>
                      </li>
                      <li> 
                        <p> <b>Fetch API: </b></p>
                        <pre><code class="language-javascript">// Отправка запроса и обработка ответа
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Ошибка:', error));</code></pre>
                      </li>
                      <li> 
                        <p> <b>Local Storage:</b></p>
                        <pre><code class="language-javascript">// Сохранение и получение данных
localStorage.setItem('username', 'John');
const user = localStorage.getItem('username');
console.log(user); // John</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li> 
                        <p>Изменить цвет текста на странице по нажатию кнопки.</p>
                      </li>
                      <li> 
                        <p>Сделать запрос к публичному API (например, GitHub API) и отобразить данные на странице.</p>
                      </li>
                      <li> 
                        <p>Реализовать сохранение пользовательских настроек (например, темы) в localStorage.</p>
                      </li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-2">Занятие 2: Spread Операторы и Деструктуризация Объектов</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b><code class="page-info__code">Spread (...) </code>и <code class="page-info__code">Rest (...) </code> операторы</b></p>
                        <ul> 
                          <li>Spread: Распаковывает элементы массива или свойства объекта.</li>
                          <li>Rest: Собирает элементы в массив.</li>
                        </ul>
                      </li>
                      <li> 
                        <p> <b>Деструктуризация массивов и объектов:</b></p>
                        <ul> 
                          <li>Присвоение значений переменным из массива или объекта.</li>
                          <li>Присвоение значений по умолчанию.</li>
                        </ul>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p> <b>Spread оператор:</b></p>
                        <pre><code class="language-javascript">const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];
console.log(arr2); // [1, 2, 3, 4, 5]</code></pre>
                      </li>
                      <li> 
                        <p> <b>Деструктуризация объектов:</b></p>
                        <pre><code class="language-javascript">const user = { name: 'John', age: 30 };
const { name, age } = user;
console.log(name); // John</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:
                      <ul> 
                        <li>Создать функцию, которая принимает неограниченное количество аргументов и возвращает их сумму. </li>
                        <li>Написать функцию, которая принимает объект пользователя и выводит его свойства в виде отдельных переменных.</li>
                      </ul>
                    </p>
                  </li>
                </ol>
                <h2 id="page-info-training-3">Занятие 3: Циклы, Типы и Структуры Данных</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>Типы данных в JavaScript: </b>Примитивы (string, number, boolean, null, undefined, symbol) и объекты (object, array, function).</p>
                      </li>
                      <li> 
                        <p> <b>Циклы:</b></p>
                        <ul> 
                          <li> <code class="page-info__code">for, while, do...while, for...of, for...in.</code></li>
                          <li>Использование ключевых слов 
                            <codecode class="page-info__code">break</codecode> и  <code class="page-info__code">continue.</code>
                          </li>
                        </ul>
                      </li>
                      <li> 
                        <p> <b>Структуры данных: </b>Массивы и объекты, их методы и свойства.</p>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p><b>Циклы:</b></p>
                        <pre><code class="language-javascript">// Цикл for используется для выполнения кода определенное количество раз.

for (let i = 0; i < 5; i++) {
  console.log(i);
}

// Этот цикл выполнит код внутри себя 5 раз, выводя в консоль числа от 0 до 4.</code></pre>
                        <pre><code class="language-javascript">// Цикл while выполняет код до тех пор, пока условие истинно.

let i = 0;
while (i < 5) {
  console.log(i);
  i++;
}

// Этот цикл также выведет числа от 0 до 4.</code></pre>
                        <pre><code class="language-javascript">// Цикл do...while сначала выполняет блок кода, а затем проверяет условие. Если условие истинно, цикл повторяется.

let i = 0;
do {
  console.log(i);
  i++;
} while (i < 5);

// Этот цикл тоже выведет числа от 0 до 4, но он гарантирует, что блок кода выполнится хотя бы один раз.</code></pre>
                        <pre><code class="language-javascript">// Цикл for...of используется для перебора значений в итерируемых объектах, таких как массивы, строки и другие коллекции.

const array = ['a', 'b', 'c'];

for (const value of array) {
  console.log(value);
}

// Этот цикл выведет каждый элемент массива: 'a', 'b', 'c'.</code></pre>
                        <pre><code class="language-javascript">// Цикл for...in используется для перебора всех перечисляемых свойств объекта.
const obj = { a: 1, b: 2, c: 3 };

for (const key in obj) {
  console.log(key, obj[key]);
}

// Этот цикл выведет ключи и значения объекта: a 1, b 2, c 3.</code></pre>
                      </li>
                      <li> 
                        <p> <b>Преобразование данных:</b></p>
                        <pre><code class="language-javascript">const num = "123";
console.log(Number(num)); // 123</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li>Написать функцию, которая фильтрует числа из массива и возвращает только те, которые больше заданного значения.</li>
                      <li>Создать объект и отобразить его ключи и значения в цикле.</li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-4">Промисы, Async/Await, Замыкания, Области Видимости и Контекст</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>Промисы:</b><code class="page-info__code">Promise</code>, состояние промиса (<code class="page-info__code">pending, fulfilled, rejected</code>), методы <code class="page-info__code">then, catch, finally.</code></p>
                      </li>
                      <li> 
                        <p> <b>Async/Await:</b>Асинхронные функции, обработка ошибок с помощью <code class="page-info__code">try...catch.</code></p>
                      </li>
                      <li> 
                        <p> <b>Замыкания:</b>Функции внутри других функций, сохранение контекста.</p>
                      </li>
                      <li> 
                        <p> <b>Области видимости: </b>Глобальная, локальная, блочная.</p>
                      </li>
                      <li> 
                        <p> <b>Контекст <code class="page-info__code">(this): </code></b>Как его менять с помощью <code class="page-info__code">call, apply, bind. </code></p>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:
                      <ul> 
                        <li> 
                          <p> <b>Промис:</b></p>
                          <pre><code class="language-javascript">const myPromise = new Promise((resolve, reject) => {
  // Состояние "pending"
  setTimeout(() => {
    // Состояние "fulfilled"
    resolve("Promise выполнен успешно!");

    // Или состояние "rejected"
    // reject("Произошла ошибка!");
  }, 2000);
});</code></pre>
                          <pre><code class="language-javascript">// Метод then() используется для обработки успешного выполнения промиса.
myPromise.then((result) => {
  console.log(result); // Выведет: "Promise выполнен успешно!"
});</code></pre>
                          <pre><code class="language-javascript">// Метод catch() используется для обработки ошибок при выполнении Promise.
myPromise
.then((result) => {
  console.log(result);
})
.catch((error) => {
  console.error("Ошибка:", error); // Выведет: "Ошибка: Произошла ошибка!" 
});</code></pre>
                          <pre><code class="language-javascript">// Метод finally() выполняется в любом случае — независимо от того, был ли промис выполнен успешно или с ошибкой.
myPromise
.then((result) => {
  console.log(result);
})
.catch((error) => {
  console.error("Ошибка:", error);
})
.finally(() => {
  console.log("Завершение промиса."); // Этот блок выполнится в любом случае.
});</code></pre>
                          <pre><code class="language-javascript">// Этот пример демонстрирует полный цикл работы с Promise, включая различные состояния и методы обработки.
function getData() {
  return new Promise((resolve, reject) => {
    const success = Math.random() > 0.5; // Случайный успех или ошибка

    setTimeout(() => {
      if (success) {
        resolve("Данные получены успешно!");
      } else {
        reject("Ошибка при получении данных!");
      }
    }, 1000);
  });
}

getData()
  .then((data) => {
    console.log(data); // Если выполнено успешно
  })
  .catch((error) => {
    console.error(error); // Если произошла ошибка
  })
  .finally(() => {
    console.log("Операция завершена."); // Выполняется в любом случае
  });</code></pre>
                        </li>
                        <li> 
                          <p> <b>Async/Await:</b></p>
                          <pre><code class="language-javascript">async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Ошибка:', error);
  }
}
fetchData(); </code></pre>
                        </li>
                        <li> 
                          <p> <b>Замыкания:</b></p>
                          <pre> <code class="language-javascript">function createCounter() {
  let count = 0;
  return function() {
    count++;
    console.log(count);
  };
}
const counter = createCounter();
counter(); // 1
counter(); //
</code></pre>
                        </li>
                      </ul>
                    </p>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li>Написать функцию с использованием промиса, который разрешается через 2 секунды.</li>
                      <li>Реализовать функцию с замыканием, которая увеличивает внутренний счетчик при каждом вызове.</li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-5">Занятие 5: Работа с Local Storage и Session Storage</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>Local Storage и Session Storage: </b>Различия между ними и случаи использования.</p>
                      </li>
                      <li> 
                        <p> <b>Методы работы: </b><code class="page-info__code">setItem, getItem, removeItem, clear.</code></p>
                      </li>
                      <li> 
                        <p> <b>Хранение сложных объектов (JSON).</b></p>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p> <b>Local Storage:</b></p>
                        <pre> <code class="language-javascript">localStorage.setItem('theme', 'dark');
const theme = localStorage.getItem('theme');
console.log(theme); //</code></pre>
                      </li>
                      <li> 
                        <p> <b>Session Storage:</b></p>
                        <pre> <code class="language-javascript">sessionStorage.setItem('sessionID', 'abc123');
const sessionID = sessionStorage.getItem('sessionID');
console.log(sessionID); // abc123
</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li>Реализовать форму входа с использованием localStorage для хранения состояния пользователя.</li>
                      <li>Создать таймер, который сохраняет свое состояние в sessionStorage и продолжает отсчет после перезагрузки страницы.</li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-6">Занятие 6: Map, Set и Связанные Списки</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>Map и Set: </b>Особенности и использование.</p>
                      </li>
                      <li> 
                        <p> <b>Связанные списки: </b>Что такое связанные списки и как их реализовать.</p>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p> <b>Map:</b></p>
                        <pre> <code class="language-javascript">const map = new Map();
map.set('name', 'John');
console.log(map.get('name')); // John</code></pre>
                      </li>
                      <li> 
                        <p> <b>Set:</b></p>
                        <pre> <code class="language-javascript">const set = new Set([1, 2, 3]);
set.add(4);
console.log(set); // Set(4) {1, 2, 3, 4}</code></pre>
                      </li>
                      <li> 
                        <p> <b>Связанный список:</b></p>
                        <pre> <code class="language-javascript">class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li>Создать <code class="page-info__code">Map</code>, который хранит пользователей и их роли, и реализовать поиск по роли.</li>
                      <li>Реализовать связанный список и методы для добавления и удаления элементов.</li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-7">Занятие 7: Работа с Timeout, SetInterval и Очистка Интервалов</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>setTimeout и setInterval: </b>Синтаксис, параметры, практическое применение.</p>
                      </li>
                      <li> 
                        <p> <b>clearTimeout и clearInterval: </b>Зачем и когда очищать таймеры и интервалы.</p>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p> <b>setTimeout</b></p>
                        <pre> <code class="language-javascript">// setTimeout используется для выполнения функции или кода с задержкой в определенное время (в миллисекундах).
setTimeout(() => {
  console.log("Привет через 3 секунды!");
}, 3000); // Задержка 3000 мс (3 секунды)
// Этот код выведет "Привет через 3 секунды!" в консоль спустя 3 секунды после запуска.</code></pre>
                      </li>
                      <li> 
                        <p> <b>setInterval</b></p>
                        <pre> <code class="language-javascript">// setInterval используется для выполнения функции или кода через регулярные интервалы времени (в миллисекундах).
const intervalId = setInterval(() => {
  console.log("Прошло 2 секунды!");
}, 2000); // Интервал 2000 мс (2 секунды)
// Этот код будет выводить "Прошло 2 секунды!" в консоль каждые 2 секунды.</code></pre>
                      </li>
                      <li> 
                        <p> <b>clearTimeout</b></p>
                        <pre> <code class="language-javascript">// clearTimeout используется для отмены выполнения функции, запланированной с помощью setTimeout.
const timeoutId = setTimeout(() => {
  console.log("Этот текст не появится, так как таймер был очищен.");
}, 5000); // Задержка 5000 мс (5 секунд)

clearTimeout(timeoutId); // Отменяем выполнение

// В этом примере сообщение не будет выведено, так как clearTimeout отменяет выполнение таймера.
</code></pre>
                      </li>
                      <li> 
                        <p> <b>clearInterval</b></p>
                        <pre> <code class="language-javascript">// clearInterval используется для остановки выполнения функции, запланированной с помощью setInterval.
const intervalId = setInterval(() => {
  console.log("Это сообщение будет выведено несколько раз.");
}, 1000); // Интервал 1000 мс (1 секунда)

// Остановим выполнение через 5 секунд
setTimeout(() => {
  clearInterval(intervalId);
  console.log("Интервал был очищен.");
}, 5000);

// Этот пример начнет выводить сообщение каждую секунду, но через 5 секунд clearInterval остановит выполнение.</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li>Создайте таймер с обратным отсчетом, который начинает отсчет от 10 и заканчивается на 0. Каждую секунду таймер должен выводить оставшееся время в консоль. Когда таймер достигнет 0, выведите сообщение "Время вышло!". Подсказка: Используйте setInterval для уменьшения значения и clearInterval для остановки.</li>
                      <li>Напишите код, который планирует вывод сообщения "Через 5 секунд будет остановка!" через 5 секунд с использованием setTimeout. Добавьте кнопку на страницу, и при нажатии на нее отмените выполнение этого таймера, используя clearTimeout. Подсказка: Вам нужно создать элемент кнопки и использовать событие onclick для его обработки.</li>
                      <li>Создайте счетчик времени, который начинает отсчет с 0 и увеличивает значение каждую секунду. Покажите это значение на веб-странице. Добавьте две кнопки: "Старт" и "Стоп". При нажатии на "Старт" таймер должен начать отсчет или продолжить с предыдущего значения. При нажатии на "Стоп" таймер должен остановиться. Подсказка: Используйте комбинацию setInterval, clearInterval, и глобальной переменной для хранения текущего значения.</li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-8">Занятие 8: Понимание Рекурсии и Избавление от Неё</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p> <b>Что такое рекурсия, примеры и случаи использования.</b></p>
                        <p>Рекурсия — это метод программирования, в котором функция вызывает саму себя для решения подзадачи, пока не достигнет базового (граничного) условия, при котором дальнейшие вызовы прекращаются.</p>
                        <p>Основные компоненты рекурсии:</p>
                        <ul> 
                          <li> 
                            <p> <b>Базовое условие (условие выхода): </b>Определяет, когда рекурсивные вызовы должны прекратиться. Без него рекурсия будет бесконечной.</p>
                          </li>
                          <li> 
                            <p> <b>Рекурсивный вызов: </b>Вызов функции самой себя с другим (обычно уменьшенным) значением параметров.</p>
                          </li>
                          <li> 
                            <p> <b>Обработка результата: </b>Часто после рекурсивного вызова происходит дополнительная обработка результатов.</p>
                          </li>
                          <p>Примеры и случаи использования рекурсии</p>
                          <ol> 
                            <li> 
                              <p>Факториал числа: Факториал числа <code class="page-info__code">n </code>(обозначается <code class="page-info__code">n!</code>) равен произведению всех положительных целых чисел до <code class="page-info__code">n</code>. Это классический пример рекурсивной функции.</p>
                              <pre> <code class="language-javascript">function factorial(n) {
  if (n <= 1) { // базовое условие
    return 1;
  }
  return n * factorial(n - 1); // рекурсивный вызов
}

console.log(factorial(5)); // 120</code></pre>
                            </li>
                            <li> 
                              <p>Числа Фибоначчи: Число Фибоначчи определяется как сумма двух предыдущих чисел. Это ещё один пример использования рекурсии.</p>
                              <pre> <code class="language-javascript">function fibonacci(n) {
  if (n <= 1) { // базовое условие
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2); // рекурсивный вызов
}

console.log(fibonacci(6)); // 8</code></pre>
                            </li>
                            <li> 
                              <p>Обход структур данных, таких как дерево или граф: Рекурсия часто используется для обхода деревьев и графов, где структура данных состоит из узлов, и каждый узел может иметь своих "детей"</p>
                              <pre> <code class="language-javascript">const tree = {
  value: 1,
  children: [
    { value: 2, children: [] },
    { value: 3, children: [{ value: 4, children: [] }] }
  ]
};

function traverseTree(node) {
  console.log(node.value); // Обработка узла

  for (let child of node.children) {
    traverseTree(child); // Рекурсивный вызов
  }
}

traverseTree(tree); // 1 2 3 4</code></pre>
                            </li>
                          </ol>
                        </ul>
                      </li>
                      <li> 
                        <p> <b>Проблемы, связанные с рекурсией (например, переполнение стека).</b></p>
                        <ol> 
                          <li> 
                            <p>Переполнение стека вызовов (Stack Overflow): Если рекурсивная функция вызывает саму себя слишком много раз без достижения базового условия, это может привести к переполнению стека вызовов, что вызовет ошибку и завершит выполнение программы.</p>
                            <pre> <code class="language-javascript">function infiniteRecursion() {
  return infiniteRecursion(); // Нет базового условия
}

// infiniteRecursion(); // Это приведет к ошибке "Maximum call stack size exceeded"</code></pre>
                          </li>
                          <li> 
                            <p>Проблема с производительностью: Рекурсивные вызовы могут быть дорогими с точки зрения памяти и времени выполнения. Например, вычисление чисел Фибоначчи с помощью наивного рекурсивного подхода имеет экспоненциальную сложность O(2^n).</p>
                          </li>
                          <li> 
                            <p>Избыточные вычисления: В рекурсивных функциях, таких как рекурсивное вычисление чисел Фибоначчи, одни и те же значения могут быть рассчитаны многократно, что приводит к неэффективному использованию ресурсов.</p>
                          </li>
                        </ol>
                      </li>
                      <li> 
                        <p> <b>Как заменить рекурсию на итеративные решения.</b></p>
                        <p> Рекурсивные функции можно преобразовать в итеративные, используя циклы (for, while) и структуры данных (например, стек) для хранения промежуточных значений. Итеративные решения обычно более эффективны по памяти и часто могут избежать переполнения стека вызовов.</p>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul> 
                      <li> 
                        <p> <b>Итеративный факториал:</b></p>
                        <pre> <code class="language-javascript">function factorialIterative(n) {
  let result = 1;
  for (let i = 2; i <= n; i++) {
    result *= i;
  }
  return result;
}

console.log(factorialIterative(5)); // 120</code></pre>
                      </li>
                      <li> 
                        <p> <b>Итеративное вычисление чисел Фибоначчи:</b></p>
                        <pre> <code class="language-javascript">function fibonacciIterative(n) {
  if (n <= 1) {
    return n;
  }

  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    let next = a + b;
    a = b;
    b = next;
  }
  return b;
}

console.log(fibonacciIterative(6)); // 8</code></pre>
                      </li>
                      <li> 
                        <p> <b>Итеративный обход дерева с использованием стека:</b></p>
                        <pre> <code class="language-javascript">function traverseTreeIterative(root) {
  const stack = [root]; // Используем стек для хранения узлов

  while (stack.length > 0) {
    const node = stack.pop();
    console.log(node.value); // Обработка узла

    // Добавляем детей узла в стек
    for (let i = node.children.length - 1; i >= 0; i--) {
      stack.push(node.children[i]);
    }
  }
}

traverseTreeIterative(tree); // 1 2 3 4</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li> 
                        <p>Написать итеративную функцию для вычисления факториала числа.</p>
                        <p>Используйте цикл for или while.</p>
                        <p>Напишите как рекурсивную, так и итеративную версию и сравните их производительность.</p>
                      </li>
                      <li> 
                        <p>Реализовать итеративное решение для обхода бинарного дерева в глубину.</p>
                        <p>Используйте стек для обхода узлов.</p>
                        <p>Реализуйте также рекурсивное решение и сравните их поведение при глубоком дереве.</p>
                      </li>
                      <li> 
                        <p>Решите задачу нахождения максимального элемента в массиве с использованием рекурсии и итерации.</p>
                        <p>Решите задачу нахождения максимального элемента в массиве с использованием рекурсии и итерации.</p>
                      </li>
                    </ul>
                  </li>
                </ol>
                <h2 id="page-info-training-9">Занятие 9: Обработка Ошибок и Базовая Отладка с Debugger</h2>
                <ol> 
                  <li> 
                    <p>Теория:</p>
                    <ul> 
                      <li> 
                        <p>Обработка ошибок в JavaScript: <code class="page-info__code">try, catch, finally, throw.</code></p>
                        <p>Обработка ошибок в JavaScript позволяет контролировать выполнение кода в случае возникновения ошибок и управлять ошибочными состояниями. Это достигается с помощью блоков try, catch, finally, а также оператора throw.</p>
                      </li>
                      <li> 
                        <p>Использование <code class="page-info__code">console.log </code>и других методов для отладки. </p>
                        <p> <code class="page-info__code">console.log </code>— это мощный инструмент для отладки JavaScript-кода, но в консоли браузера доступны и другие методы.</p>
                      </li>
                      <li> 
                        <p>Как использовать <code class="page-info__code">debugger</code>в браузере.</p>
                        <p>Инструкция <code class="page-info__code">debugger</code>в JavaScript ставит "точку останова" в коде. Когда JavaScript встречает инструкцию  <code class="page-info__code">debugger</code>, выполнение кода останавливается, и появляется возможность отладки в консоли разработчика браузера.</p>
                        <ol> 
                          <li>Открытие консоли разработчика:
                            <ul> 
                              <li>Нажмите <code class="page-info__code">F12 </code>или <code class="page-info__code">Ctrl+Shift+I</code>в браузере (например, Google Chrome, Firefox).</li>
                              <li>Перейдите на вкладку "Sources" (Источники) в панели инструментов разработчика.</li>
                            </ul>
                          </li>
                          <li>Добавление точки останова вручную:
                            <ul> 
                              <li>Выберите файл JavaScript из списка файлов.</li>
                              <li>Найдите строку, в которой вы хотите поставить точку останова.</li>
                              <li>Нажмите на номер строки слева, чтобы установить точку останова.</li>
                            </ul>
                          </li>
                          <li>Использование панели отладки:
                            <ul> 
                              <li>После остановки кода (либо с помощью инструкции <code class="page-info__code">debugger</code>, либо с установленной точкой останова), используйте панель отладки для выполнения кода по шагам, просмотра переменных, стеков вызовов и выражений.</li>
                            </ul>
                          </li>
                          <li>Пошаговая отладка:
                            <ul> 
                              <li>Continue (<code class="page-info__code">F8</code>): Продолжает выполнение до следующей точки останова.</li>
                              <li>Step Over (<code class="page-info__code">F10</code>): Выполняет текущую строку и переходит к следующей.</li>
                              <li>Step Into (<code class="page-info__code">F11</code>): Входит в вызываемую функцию.</li>
                              <li>Step Out (<code class="page-info__code">Shift+F11</code>): Выходит из текущей функции.</li>
                            </ul>
                          </li>
                        </ol>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Примеры:</p>
                    <ul>
                      <li> 
                        <p> <b>Блоки </b><code class="page-info__code">try...catch:</code></p>
                        <ul> 
                          <li> 
                            <p>Блок <code class="page-info__code">try </code>используется для выполнения кода, который может вызвать ошибку.</p>
                          </li>
                          <li> 
                            <p>Если ошибка возникает, выполнение переходит в блок <code class="page-info__code">catch</code>, где можно обработать ошибку.</p>
                          </li>
                          <li> 
                            <p> Блок <code class="page-info__code">finally </code>выполняется независимо от того, была ли ошибка или нет.</p>
                          </li>
                        </ul>
                        <pre> <code class="language-javascript">try {
  let result = 10 / 0; // Попытка деления на 0
  console.log(result); // Infinity, ошибки нет, так что выполнение продолжается

  let user = JSON.parse("{ name: 'Alice' }"); // Неправильный JSON (кавычки вокруг ключа name должны быть двойными)
} catch (error) {
  console.error("Произошла ошибка:", error.message); // Обрабатываем ошибку, например, синтаксическую ошибку
} finally {
  console.log("Этот блок выполнится в любом случае."); // Выполнится всегда
}</code></pre>
                      </li>
                      <li> 
                        <p> <b>Блок <code class="page-info__code">try...catch </code>с <code class="page-info__code">throw:</code></b>Оператор throw используется для генерации пользовательских ошибок. Это позволяет управлять ошибками и реагировать на специфические сценарии.</p>
                        <pre> <code class="language-javascript">function divide(a, b) {
  if (b === 0) {
    throw new Error("Деление на ноль невозможно."); // Генерируем ошибку
  }
  return a / b;
}

try {
  console.log(divide(10, 0)); // Это вызовет ошибку
} catch (error) {
  console.error("Ошибка деления:", error.message); // Обработка ошибки
} finally {
  console.log("Попытка деления завершена."); // Выполнится всегда
}</code></pre>
                      </li>
                      <li> 
                        <p> <b>Использование блока <code class="page-info__code">finally </code>для очистки ресурсов:</b>Блок <code class="page-info__code">finally </code>часто используется для выполнения завершающих действий, таких как освобождение ресурсов или закрытие соединений.</p>
                        <pre> <code class="language-javascript">function processFile(file) {
  try {
    console.log("Открытие файла:", file);
    // Обработка файла...
    throw new Error("Ошибка при обработке файла!"); // Случайная ошибка
  } catch (error) {
    console.error("Ошибка:", error.message);
  } finally {
    console.log("Закрытие файла:", file); // Всегда выполняется
  }
}

processFile("example.txt");</code></pre>
                      </li>
                      <li> 
                        <p> <b>Используется для вывода информации в консоль.</b></p>
                        <pre> <code class="language-javascript">const name = "Alice";
console.log("Имя пользователя:", name);</code></pre>
                      </li>
                      <li> 
                        <p> <b>Используется для вывода сообщений об ошибках в консоль. Важно использовать этот метод для различения обычных сообщений и ошибок.</b></p>
                        <pre> <code class="language-javascript">console.error("Произошла ошибка при обработке данных!");</code></pre>
                      </li>
                      <li> 
                        <p> <b>Используется для вывода предупреждений в консоль.</b></p>
                        <pre> <code class="language-javascript">console.warn("Предупреждение: Вы используете устаревший API!");</code></pre>
                      </li>
                      <li> 
                        <p> <b>Используется для отображения массивов или объектов в виде таблицы в консоли.</b></p>
                        <pre> <code class="language-javascript">const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
];

console.table(users);</code></pre>
                      </li>
                      <li> 
                        <p> <b>Используется для измерения времени выполнения кода.</b></p>
                        <pre> <code class="language-javascript">console.time("Время выполнения цикла");
for (let i = 0; i < 1000000; i++) {
  // Some loop
}
console.timeEnd("Время выполнения цикла");</code></pre>
                      </li>
                      <li> 
                        <p> <b>Используется для создания групп сообщений в консоли.</b></p>
                        <pre> <code class="language-javascript">console.group("Детали пользователя");
console.log("Имя: Alice");
console.log("Возраст: 25");
console.groupEnd();</code></pre>
                      </li>
                      <li> 
                        <p> <b>Пример использования debugger</b></p>
                        <pre> <code class="language-javascript">function calculateSquare(number) {
  debugger; // Остановка выполнения здесь
  return number * number;
}

const result = calculateSquare(5);
console.log("Результат:", result);</code></pre>
                      </li>
                    </ul>
                  </li>
                  <li> 
                    <p>Практические задачи:</p>
                    <ul> 
                      <li>Обработка ошибок: Напишите функцию, которая принимает строку и возвращает ее длину. Если входные данные не являются строкой, используйте <code class="page-info__code">throw </code>для генерации ошибки, а затем обработайте ее с помощью <code class="page-info__code">try...catch.</code></li>
                      <li>Отладка с <code class="page-info__code">console.log</code>и другими методами: Напишите программу, которая создает массив объектов пользователей и использует <code class="page-info__code">console.table()</code>для отображения их в таблице. Добавьте также вывод ошибок и предупреждений.</li>
                      <li>Использование <code class="page-info__code">debugger</code>: Создайте функцию для вычисления факториала числа с использованием цикла <code class="page-info__code">for</code>. Добавьте <code class="page-info__code">debugger</code>в код и используйте его в консоли браузера для пошаговой отладки, чтобы увидеть, как меняется значение на каждом шаге.</li>
                    </ul>
                  </li>
                </ol>
              </div>
            </section>
    </div>
    <div class="to-top"></div>
    <script src="js/jquery-3.2.1.min.js"></script>
    <script src="js/jquery.modal.min.js"></script>
    <script src="js/jquery.mask.min.js"></script>
    <script src="js/prism.js"></script>
    <script src="js/svg4everybody.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>$(document).ready(function () {	svg4everybody({});});</script>
    <script src="js/script.js"></script>
  </body>
</html>